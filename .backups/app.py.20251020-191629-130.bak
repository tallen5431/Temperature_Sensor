import os, json, threading, time, datetime
from pathlib import Path

import pandas as pd
import requests

import dash
from dash import Dash, html, dcc, Input, Output, State, no_update
import dash_bootstrap_components as dbc
from flask import request, jsonify

# -------------------- Settings & Files --------------------
BASE_DIR = Path(__file__).resolve().parent
CSV_FILE = BASE_DIR / "temperature_log.csv"
CONFIG_FILE = BASE_DIR / "config.json"
ESP32_URL = os.getenv("ESP32_URL", "http://192.168.1.202/")

if not CSV_FILE.exists():
    pd.DataFrame(columns=["timestamp", "temperature_c", "temperature_f"]).to_csv(CSV_FILE, index=False)

# Default config
_config_lock = threading.Lock()
_config = {"interval_sec": 5, "pull_enabled": True}

# Load persisted config if present
if CONFIG_FILE.exists():
    try:
        _config.update(json.loads(CONFIG_FILE.read_text(encoding="utf-8")))
    except Exception:
        pass

# -------------------- Helpers --------------------

def _save_config():
    with _config_lock:
        CONFIG_FILE.write_text(json.dumps(_config, indent=2), encoding="utf-8")


def append_row(ts: str, t_c: float, t_f: float):
    df = pd.DataFrame([[ts, t_c, t_f]], columns=["timestamp", "temperature_c", "temperature_f"])
    df.to_csv(CSV_FILE, mode="a", header=False, index=False)


def normalize_payload(payload: dict):
    """Accepts a variety of keys from devices and normalizes to (ts, t_c, t_f)."""
    now = datetime.datetime.now().isoformat(timespec="seconds")
    ts = payload.get("timestamp") or payload.get("ts") or now

    # Possible keys for Celsius/Fahrenheit
    c_keys = ["temperature_c", "temp_c", "t_c", "c"]
    f_keys = ["temperature_f", "temp_f", "t_f", "f"]

    t_c = None
    t_f = None
    for k in c_keys:
        if k in payload:
            t_c = float(payload[k])
            break
    for k in f_keys:
        if k in payload:
            t_f = float(payload[k])
            break

    if t_c is None and t_f is None:
        raise ValueError("No temperature value found in payload")

    if t_c is None and t_f is not None:
        t_c = (t_f - 32.0) * 5.0 / 9.0
    if t_f is None and t_c is not None:
        t_f = (t_c * 9.0 / 5.0) + 32.0

    return ts, float(t_c), float(t_f)


def fetch_temp():
    """Pull mode: fetch current reading from ESP32_URL and return tuple or None."""
    try:
        r = requests.get(ESP32_URL, timeout=3)
        r.raise_for_status()
        lines = r.text.strip().splitlines()
        if len(lines) < 2:
            return None
        parts = [p.strip() for p in lines[1].split(',')]
        if len(parts) < 3:
            return None
        t_c = float(parts[1])
        t_f = float(parts[2])
        ts = datetime.datetime.now().isoformat(timespec="seconds")
        return ts, t_c, t_f
    except Exception:
        return None

# -------------------- Background logger (optional pull) --------------------
_stop_evt = threading.Event()

def logger_loop():
    while not _stop_evt.is_set():
        with _config_lock:
            interval = max(1, int(_config.get("interval_sec", 5)))
            pull_enabled = bool(_config.get("pull_enabled", True))
        if pull_enabled:
            row = fetch_temp()
            if row:
                ts, t_c, t_f = row
                append_row(ts, t_c, t_f)
        time.sleep(interval)


def start_logger_thread():
    t = threading.Thread(target=logger_loop, daemon=True)
    t.start()

# -------------------- Dash App --------------------
app = Dash(__name__, external_stylesheets=[dbc.themes.CYBORG])
server = app.server
app.title = "Temperature Monitor"

app.layout = dbc.Container([
    html.H3("ðŸŒ¡ï¸ Temperature Monitor & Ingest API"),
    dbc.Row([
        dbc.Col(dbc.Card(dbc.CardBody([
            html.H5("Logging Controls"),
            dbc.Row([
                dbc.Col([
                    dbc.Label("Pull mode enabled"),
                    dcc.Checklist(id="pull-enabled", options=[{"label": " Enabled", "value": "on"}],
                                   value=["on"] if _config.get("pull_enabled", True) else [])
                ], width=6),
                dbc.Col([
                    dbc.Label("Interval (sec)"),
                    dcc.Input(id="interval-sec", type="number", min=1, step=1, value=int(_config.get("interval_sec", 5)))
                ], width=6),
            ], className="gy-2"),
            html.Button("Save", id="save-config", className="btn btn-primary btn-sm mt-2"),
            html.Div(id="save-status", className="mt-2 text-info")
        ])), width=5),
        dbc.Col(dbc.Card(dbc.CardBody([
            html.H5("Latest Reading"),
            html.Div(id="latest-reading", className="display-6"),
            dcc.Interval(id="ui-refresh", interval=3000, n_intervals=0)
        ])), width=7)
    ], className="mt-3"),
    dbc.Alert([
        html.Div("Device push endpoint: POST JSON to "),
        html.Code("/api/ingest"),
        html.Span(" with keys like "),
        html.Code("{ 'timestamp': '2025-10-20T12:00:00', 'temperature_c': 24.5 }")
    ], color="dark", className="mt-4"),
    html.Div([
        html.Small("Config API: GET/POST "), html.Code("/api/config"), html.Small(" (JSON)")
    ], className="text-muted")
], fluid=True)

# ---- Callbacks ----
@app.callback(
    Output("save-status", "children"),
    Output("pull-enabled", "value"),
    Output("interval-sec", "value"),
    Input("save-config", "n_clicks"),
    State("pull-enabled", "value"),
    State("interval-sec", "value"),
    prevent_initial_call=True
)
def save_config(n, pull_vals, interval_val):
    try:
        pull = bool(pull_vals and "on" in pull_vals)
        interval = max(1, int(interval_val or 5))
        with _config_lock:
            _config["pull_enabled"] = pull
            _config["interval_sec"] = interval
        _save_config()
        return "âœ… Saved", (["on"] if pull else []), interval
    except Exception as e:
        return f"âŒ {e}", no_update, no_update


@app.callback(
    Output("latest-reading", "children"),
    Input("ui-refresh", "n_intervals")
)
def show_latest(_):
    try:
        df = pd.read_csv(CSV_FILE)
        if df.empty:
            return "(no data yet)"
        row = df.tail(1).iloc[0]
        return f"{row['timestamp']} â€” {row['temperature_c']:.2f}Â°C / {row['temperature_f']:.2f}Â°F"
    except Exception:
        return "(no data yet)"

# -------------------- REST API --------------------
@server.get("/api/config")
def get_config():
    with _config_lock:
        return jsonify(dict(_config))


@server.post("/api/config")
def set_config():
    try:
        body = request.get_json(force=True) or {}
        with _config_lock:
            if "interval_sec" in body:
                _config["interval_sec"] = max(1, int(body["interval_sec"]))
            if "pull_enabled" in body:
                _config["pull_enabled"] = bool(body["pull_enabled"])
        _save_config()
        return jsonify({"ok": True, **_config})
    except Exception as e:
        return jsonify({"ok": False, "error": str(e)}), 400


@server.post("/api/ingest")
def ingest():
    try:
        payload = request.get_json(force=True) or {}
        ts, t_c, t_f = normalize_payload(payload)
        append_row(ts, t_c, t_f)
        return jsonify({"ok": True, "timestamp": ts, "temperature_c": t_c, "temperature_f": t_f})
    except Exception as e:
        return jsonify({"ok": False, "error": str(e)}), 400


@server.get("/health")
def health():
    return {"ok": True, "time": datetime.datetime.now().isoformat()}


if __name__ == "__main__":
    host = os.getenv("HOST", "0.0.0.0")
    port = int(os.getenv("PORT", "8088"))
    start_logger_thread()  # pull-mode thread (can be disabled via /api/config)
    try:
        app.run(host=host, port=port, debug=False)
    finally:
        _stop_evt.set()
