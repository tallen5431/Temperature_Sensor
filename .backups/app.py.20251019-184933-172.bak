import dash
from dash import html, dcc
from dash.dependencies import Input, Output, State
import pandas as pd
import requests, datetime, os
import dash_bootstrap_components as dbc

# --- Configuration ---
ESP32_URL = os.getenv("ESP32_URL", "http://192.168.1.202/")
CSV_FILE = "temperature_log.csv"
DEFAULT_INTERVAL = 5000  # ms
ROLLING_WINDOW_MIN = 10  # minutes

# --- Ensure CSV exists ---
if not os.path.exists(CSV_FILE):
    pd.DataFrame(columns=["timestamp", "temperature_c", "temperature_f"]).to_csv(CSV_FILE, index=False)

def fetch_temp():
    """Fetch the CSV-style response from ESP32 and parse into floats."""
    try:
        r = requests.get(ESP32_URL, timeout=3)
        r.raise_for_status()
        lines = r.text.strip().splitlines()
        if len(lines) < 2:
            return None
        parts = lines[1].split(',')
        if len(parts) < 3:
            return None
        t_c = float(parts[1])
        t_f = float(parts[2])
        ts = datetime.datetime.now().isoformat(timespec="seconds")
        return ts, t_c, t_f
    except Exception as e:
        print(f"[WARN] fetch_temp failed: {e}")
        return None

def append_csv(reading):
    """Append one reading to the log file immediately (no buffering)."""
    try:
        ts, c, f = reading
        with open(CSV_FILE, "a", newline="", encoding="utf-8") as f_out:
            f_out.write(f"{ts},{c:.2f},{f:.2f}\n")
            f_out.flush()
    except Exception as e:
        print(f"[WARN] Failed to append CSV: {e}")

def read_csv():
    """Read recent data for plotting (last N minutes)."""
    try:
        df = pd.read_csv(CSV_FILE)
        if df.empty:
            return pd.DataFrame(columns=["timestamp", "temperature_c", "temperature_f"])
        df["timestamp"] = pd.to_datetime(df["timestamp"], errors="coerce")
        cutoff = datetime.datetime.now() - datetime.timedelta(minutes=ROLLING_WINDOW_MIN)
        return df[df["timestamp"] > cutoff]
    except Exception:
        return pd.DataFrame(columns=["timestamp", "temperature_c", "temperature_f"])

# --- Dash App Setup ---
app = dash.Dash(__name__, title="ESP32 Temperature Monitor", external_stylesheets=[dbc.themes.CYBORG])
server = app.server

app.layout = dbc.Container([
    dbc.Row(dbc.Col(html.H3("üå°Ô∏è ESP32 Temperature Monitor", className="text-center my-2"))),

    dbc.Row([
        dbc.Col(html.Div(id="status-indicator"), width=2),
        dbc.Col(html.Div(id="live-temp", className="fw-bold"), width=10)
    ], align="center"),

    dbc.Row(dbc.Col(dcc.Graph(id="temp-graph"), width=12)),

    dbc.Row([
        dbc.Col([
            html.Label("Refresh Interval (seconds)"),
            dcc.Slider(
                id="interval-slider",
                min=2, max=10, step=1, value=DEFAULT_INTERVAL / 1000,
                marks={i: str(i) for i in range(2, 11)}
            )
        ], width=8),
        dbc.Col([
            html.Br(),
            html.A("‚¨áÔ∏è Download CSV", href="/download", target="_blank",
                   className="btn btn-secondary w-100 mb-2"),
            html.Button("üíæ Save Now", id="save-now",
                        className="btn btn-primary w-100")
        ], width=4)
    ], className="my-2"),

    dcc.Interval(id="interval", interval=DEFAULT_INTERVAL, n_intervals=0)
], fluid=True)

# --- CSV Download Endpoint ---
@app.server.route("/download")
def serve_csv():
    if not os.path.exists(CSV_FILE):
        return "No data yet", 404
    with open(CSV_FILE, "r", encoding="utf-8") as f:
        content = f.read()
    return content, 200, {
        "Content-Type": "text/csv",
        "Content-Disposition": "inline; filename=temperature_log.csv"
    }

# --- Main Update Callback ---
@app.callback(
    Output("temp-graph", "figure"),
    Output("live-temp", "children"),
    Output("status-indicator", "children"),
    Input("interval", "n_intervals"),
    Input("save-now", "n_clicks"),
    State("interval-slider", "value")
)
def update_graph(n, save_clicks, slider_val):
    interval_ms = int(slider_val * 1000)

    # Fetch temperature from ESP32
    reading = fetch_temp()
    status_icon = html.Span("üü¢ Online", style={"color": "lime"}) if reading else html.Span("üî¥ Offline", style={"color": "red"})
    if reading:
        append_csv(reading)

    # Read data for plotting
    df = read_csv()
    if df.empty:
        return (
            {"data": [], "layout": {"template": "plotly_dark", "title": "No data yet"}},
            "Waiting for sensor data...",
            status_icon
        )

    fig = {
        "data": [
            {"x": df["timestamp"], "y": df["temperature_c"], "mode": "lines+markers", "name": "Temp ¬∞C"},
            {"x": df["timestamp"], "y": df["temperature_f"], "mode": "lines", "name": "Temp ¬∞F", "yaxis": "y2"},
        ],
        "layout": {
            "template": "plotly_dark",
            "xaxis": {"title": "Time"},
            "yaxis": {"title": "¬∞C"},
            "yaxis2": {"title": "¬∞F", "overlaying": "y", "side": "right"},
            "margin": {"l": 60, "r": 60, "t": 40, "b": 40},
            "height": 500
        }
    }

    if reading:
        ts, c, f = reading
        live = f"Last reading: {ts} ‚Äî {c:.2f} ¬∞C / {f:.2f} ¬∞F"
    else:
        live = "No new reading yet."

    return fig, live, status_icon


if __name__ == "__main__":
    host = os.getenv("HOST", "0.0.0.0")
    port = int(os.getenv("PORT", "8088"))
    print(f"[INFO] Dash server running at http://{host}:{port}")
    app.run(host=host, port=port, debug=False)
