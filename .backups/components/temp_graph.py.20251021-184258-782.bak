from __future__ import annotations
import numpy as np
import pandas as pd
import plotly.graph_objects as go
from dash import html, dcc, Input, Output
import dash_bootstrap_components as dbc
from pathlib import Path
from datetime import datetime, timezone

# --- Public UI section -------------------------------------------------------
GraphSection = dbc.Card(
    dbc.CardBody([
        html.Div(
            className="d-flex justify-content-between align-items-center mb-2",
            children=[
                html.H5("Temperature Graph", className="mb-0"),
                html.Small(id="graph-status", className="text-muted")
            ],
        ),
        dbc.Row([
            dbc.Col([
                dbc.Label("Time range"),
                dcc.Dropdown(
                    id="range-select",
                    options=[
                        {"label": "Last 15 min", "value": "15m"},
                        {"label": "Last 1 hour", "value": "1h"},
                        {"label": "Last 6 hours", "value": "6h"},
                        {"label": "Last 24 hours", "value": "24h"},
                        {"label": "All", "value": "all"}
                    ],
                    value="1h",
                    clearable=False,
                )
            ], width=6),
            dbc.Col([
                dbc.Label("Display"),
                dcc.Dropdown(
                    id="unit-select",
                    options=[
                        {"label": "Celsius (°C)", "value": "C"},
                        {"label": "Fahrenheit (°F)", "value": "F"}
                    ],
                    value="C",
                    clearable=False
                )
            ], width=6),
        ], className="gy-2"),
        dbc.Row([
            dbc.Col([
                dcc.Checklist(
                    id="show-markers",
                    options=[{"label": " Show points", "value": "on"}],
                    value=["on"],  # default ON
                    labelStyle={"cursor": "pointer"},
                    inputStyle={"marginRight": "0.35rem"}
                ),
            ], width="auto"),
        ], className="gy-1 mb-1"),
        dcc.Graph(id="temp-graph", figure=go.Figure(), config={"displaylogo": False}),
        # Interval now follows main control in app.py via callback input "interval-sec"
        dcc.Interval(id="graph-interval", interval=5000, n_intervals=0)
    ])
)

# --- Helpers ----------------------------------------------------------------

def _load_df(csv_file: Path) -> pd.DataFrame:
    try:
        df = pd.read_csv(csv_file)
        if df.empty:
            return pd.DataFrame(columns=["timestamp", "temperature_c", "temperature_f"])  # empty
        df["timestamp"] = pd.to_datetime(df["timestamp"], errors="coerce")
        df = df.dropna(subset=["timestamp"]).sort_values("timestamp").reset_index(drop=True)
        return df
    except Exception:
        return pd.DataFrame(columns=["timestamp", "temperature_c", "temperature_f"])  # empty


def _filter_range(df: pd.DataFrame, range_key: str) -> pd.DataFrame:
    if df.empty or range_key == "all":
        return df
    now = df["timestamp"].max()
    if pd.isna(now):
        return df
    mapping = {
        "15m": pd.Timedelta(minutes=15),
        "1h": pd.Timedelta(hours=1),
        "6h": pd.Timedelta(hours=6),
        "24h": pd.Timedelta(hours=24),
    }
    delta = mapping.get(range_key)
    if not delta:
        return df
    return df[df["timestamp"] >= (now - delta)]


def _downsample(df: pd.DataFrame, target_max_points: int = 1500) -> pd.DataFrame:
    if df.empty:
        return df
    n = len(df)
    if n <= target_max_points:
        return df
    idx = np.linspace(0, n - 1, target_max_points).astype(int)
    return df.iloc[idx]


def _make_figure(df: pd.DataFrame, unit: str, show_markers: bool) -> go.Figure:
    fig = go.Figure()

    if not df.empty:
        # Choose series
        if unit == "F":
            y = df["temperature_f"].astype(float)
            y_title = "°F"
            name = "Temp °F"
        else:
            y = df["temperature_c"].astype(float)
            y_title = "°C"
            name = "Temp °C"

        x = df["timestamp"]

        # Auto marker toggle: many points -> lines only
        auto_markers = len(df) <= 500
        markers = show_markers or auto_markers

        # Subtle glow underlay for readability
        fig.add_trace(go.Scatter(
            x=x, y=y,
            mode="lines",
            name=name,
            line=dict(width=6),
            opacity=0.18,
            hoverinfo="skip",
            showlegend=False
        ))

        # Main line
        fig.add_trace(go.Scatter(
            x=x, y=y,
            mode="lines+markers" if markers else "lines",
            name=name,
            line=dict(width=2.5),
            marker=dict(size=4) if markers else None,
            hovertemplate="%{x|%Y-%m-%d %H:%M:%S}<br><b>%{y:.2f} " + y_title + "</b><extra></extra>",
        ))

        # Highlight the latest point
        latest_x = x.iloc[-1]
        latest_y = float(y.iloc[-1])
        fig.add_trace(go.Scatter(
            x=[latest_x], y=[latest_y],
            mode="markers",
            name="Latest",
            marker=dict(size=10, symbol="circle-open"),
            hovertemplate="<b>Latest</b><br>%{x|%Y-%m-%d %H:%M:%S}<br><b>%{y:.2f} " + y_title + "</b><extra></extra>",
            showlegend=False,
        ))

        # y=0 baseline and headroom
        if len(y) and np.isfinite(y).any():
            y_valid = y[np.isfinite(y)]
            y_max = float(np.nanmax(y_valid)) if len(y_valid) else 1.0
        else:
            y_max = 1.0
        y_max = max(1.0, y_max * 1.05)

        fig.update_layout(
            margin=dict(l=18, r=18, t=18, b=42),
            xaxis_title="Time",
            yaxis=dict(
                title=y_title,
                rangemode="tozero",
                range=[0, y_max],
                zeroline=True, zerolinewidth=1,
                gridcolor="rgba(255,255,255,0.08)"
            ),
            xaxis=dict(
                gridcolor="rgba(255,255,255,0.05)",
                showspikes=True,
                spikemode="across",
                spikesnap="cursor",
                spikedash="dot"
            ),
            hovermode="x unified",
            legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
            transition_duration=0
        )
    else:
        fig.update_layout(
            margin=dict(l=18, r=18, t=18, b=42),
            annotations=[dict(text="No data yet", x=0.5, y=0.5, xref="paper", yref="paper", showarrow=False)]
        )

    return fig


def _status_text(df: pd.DataFrame) -> str:
    if df.empty:
        return "0 samples — waiting for data…"
    n = len(df)
    ts = df["timestamp"].iloc[-1]
    try:
        last_dt = ts.to_pydatetime()
        if last_dt.tzinfo is None:
            last_dt = last_dt.replace(tzinfo=timezone.utc)
        age_s = max(0, int((datetime.now(timezone.utc) - last_dt).total_seconds()))
        return f"{n} samples — last update {age_s}s ago"
    except Exception:
        return f"{n} samples"

# --- Callback registration ---------------------------------------------------

def register_callbacks(app, csv_file: Path):
    @app.callback(
        Output("temp-graph", "figure"),
        Output("graph-interval", "interval"),
        Output("graph-status", "children"),
        Input("graph-interval", "n_intervals"),
        Input("range-select", "value"),
        Input("unit-select", "value"),
        Input("interval-sec", "value"),  # unified with main logging control
        Input("show-markers", "value"),
        prevent_initial_call=False,
    )
    def _update_graph(_n, range_key, unit, interval_sec, markers_val):
        df = _load_df(csv_file)
        df = _filter_range(df, range_key or "1h")
        df = _downsample(df, 1500)

        show_markers = bool(markers_val and "on" in markers_val)
        fig = _make_figure(df, unit or "C", show_markers)

        # Tie auto-refresh directly to the main interval control
        interval_ms = max(1, int(interval_sec or 5)) * 1000
        status = _status_text(df)
        return fig, interval_ms, status
